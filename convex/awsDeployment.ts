import { action } from "./_generated/server";
import { v } from "convex/values";
import { EC2Client, RunInstancesCommand } from "@aws-sdk/client-ec2";
import { RDSClient, CreateDBInstanceCommand } from "@aws-sdk/client-rds";

export const provisionInfrastructure = action({
    args: {
        diagramId: v.id("diagrams"),
        nodes: v.array(v.any()), // We pass the react flow nodes to parse
    },
    handler: async (ctx, args) => {
        // In a real hackathon demo, we don't want to actually spend money or wait 20 minutes for RDS.
        // We will instantiate the clients, but mock the final network call and return simulated AWS Resource IDs 
        // to prove the architecture-to-IaC pipeline works flawlessly.

        console.log(`[AWS Provisioner] Starting deployment for Diagram: ${args.diagramId}`);

        const results = [];

        // 1. Initialize AWS Clients (Using dummy credentials for demo safety)
        const ec2 = new EC2Client({ region: "us-east-1", credentials: { accessKeyId: "mock", secretAccessKey: "mock" } });
        const rds = new RDSClient({ region: "us-east-1", credentials: { accessKeyId: "mock", secretAccessKey: "mock" } });

        for (const node of args.nodes) {
            const data = node.data;

            if (data.componentType === 'api' || data.componentType === 'auth' || data.componentType === 'monitoring') {
                // Map to EC2 or ECS
                const instanceType = data.instanceCount > 1 ? "t3.medium" : "t2.micro";
                console.log(`[AWS EC2] Provisioning ${data.componentType} Server (${instanceType})...`);

                // Construct the actual AWS Command (but we won't execute it to save $ and time)
                const command = new RunInstancesCommand({
                    ImageId: "ami-0c55b159cbfafe1f0", // Amazon Linux 2
                    InstanceType: instanceType,
                    MinCount: 1,
                    MaxCount: data.instanceCount || 1,
                    TagSpecifications: [
                        { ResourceType: "instance", Tags: [{ Key: "Name", Value: `ArchSentinel-${data.label}` }] }
                    ]
                });

                results.push({
                    componentId: node.id,
                    awsService: "EC2",
                    resourceId: `i-0${Math.random().toString(36).substring(2, 10)}`,
                    status: "Running",
                    details: `Deployed ${data.instanceCount || 1}x ${instanceType} instances.`
                });
            }

            if (data.componentType === 'db') {
                // Map to RDS
                console.log(`[AWS RDS] Provisioning Managed Database...`);

                const dbCommand = new CreateDBInstanceCommand({
                    DBInstanceIdentifier: `archsentinel-${node.id}`,
                    AllocatedStorage: 20,
                    DBInstanceClass: "db.t3.micro",
                    Engine: "postgres",
                    MasterUsername: "admin",
                    MasterUserPassword: "AutoGeneratedSecurePassword123!",
                    PubliclyAccessible: data.exposure === "Public",
                    StorageEncrypted: data.encryptionAtRest
                });

                results.push({
                    componentId: node.id,
                    awsService: "RDS",
                    resourceId: `archsentinel-db-${Math.floor(Math.random() * 1000)}`,
                    status: "Creating",
                    details: `Provisioning Managed PostgreSQL. Encryption: ${data.encryptionAtRest ? "Enabled" : "Disabled"}`
                });
            }
        }

        // Return the mock deployment log
        return {
            success: true,
            message: "Infrastructure-as-Code execution completed.",
            resources: results
        };
    }
});
